2007-05-02  Brian Warner  <warner@lothar.com>

	* foolscap/reconnector.py (Reconnector._failed): simplify
	log/no-log logic

	* foolscap/slicers/unicode.py (UnicodeConstraint): add a new
	constraint that only accepts unicode objects. It isn't complete:
	I've forgotten how the innards of Constraints work, and as a
	result this one is too permissive: it will probably accept too
	many tokens over the wire before raising a Violation (although the
	post-receive just-before-the-method-is-called check should still
	be enforced, so application code shouldn't notice the issue).
	* foolscap/test/test_schema.py (ConformTest.testUnicode): test it
	(CreateTest.testMakeConstraint): check the typemap too
	* foolscap/test/test_call.py (TestCall.testMegaSchema): test in a call
	* foolscap/test/common.py: same

	* foolscap/constraint.py (ByteStringConstraint): rename
	StringConstraint to ByteStringConstraint, to more accurately
	describe its function. This constraint will *not* accept unicode
	objects.
	* foolscap/call.py, foolscap/copyable.py, foolscap/referenceable.py:
	* foolscap/slicers/vocab.py: same

	* foolscap/schema.py (AnyStringConstraint): add a new constraint
	to accept either bytestrings or unicode objects. I don't think it
	actually works yet, particularly when used inside containers.
	(constraintMap): map 'str' to ByteStringConstraint for now. Maybe
	someday it should be mapped to AnyStringConstraint, but not today.
	Map 'unicode' to UnicodeConstraint.


	* foolscap/pb.py (Tub.getReference): assert that the Tub is
	already running, either because someone called Tub.startService(),
	or because we've been attached (with tub.setServiceParent) to a
	running service. This requirement appeared with the
	connector-tracking code, and I hope to relax it at some
	point (such that any pre-startService getReferences will be queued
	and serviced when the Tub is finally started), but for this
	release it is a requirement to start the service before trying to
	use it.
	(Tub.connectTo): same
	* doc/using-pb.xhtml: document it
	* doc/listings/pb1client.py: update example to match
	* doc/listings/pb2client.py: update example to match
	* doc/listings/pb3client.py: update example to match

	* foolscap/pb.py (Tub.connectorFinished): if, for some reason,
	we're removing the same connector twice, log and ignore rather
	than explode. I can't find a code path that would allow this, but
	I *have* seen it occur in practice, and the results aren't pretty.
	Since the whole connection-tracking thing is really for the
	benefit of unit tests anyways (who want to know when
	Tub.stopService is done), I think it's more important to keep
	application code running.

	* foolscap/negotiate.py (TubConnector.shutdown): clear out
	self.remainingLocations too, in case it helps to shut things down
	faster. Add some comments.

	* foolscap/negotiate.py (Negotiation): improve error-message
	delivery, by keeping track of what state the receiver is in (i.e.
	whether we should send them an HTTP error block, an rfc822-style
	error-block, or a banana ERROR token).
	(Negotiation.switchToBanana): empty self.buffer, to make sure that
	any extra data is passed entirely to the new Banana protocol and
	none of it gets passed back to ourselves
	(Negotiation.dataReceived): same, only recurse if there's something
	still in self.buffer. In other situtations we recurse here because
	we might have somehow received data for two separate phases in a
	single packet.

	* foolscap/banana.py (Banana.sendError): rather than explode when
	trying to send an overly-long error message, just truncate it.

2007-04-30  Brian Warner  <warner@lothar.com>

	* foolscap/broker.py (Broker.notifyOnDisconnect): if the
	RemoteReference is already dead, notify the callback right away.
	Previously we would never notify them, which was a problem.
	(Broker.dontNotifyOnDisconnect): be tolerant of attempts to
	unregister callbacks that have already fired. I think this makes it
	easier to write correct code, but on the other hand it loses the
	assertion feedback if somebody tries to unregister something that
	was never registered in the first place.
	* foolscap/test/test_call.py (TestCall.testNotifyOnDisconnect):
	test this new tolerance
	(TestCall.testNotifyOnDisconnect_unregister): same
	(TestCall.testNotifyOnDisconnect_already): test that a handler
	fires when the reference was already broken

	* foolscap/call.py (InboundDelivery.logFailure): don't use
	f.getTraceback() on string exceptions: twisted explodes
	(FailureSlicer.getStateToCopy): same
	* foolscap/test/test_call.py (TestCall.testFailStringException):
	skip the test on python2.5, since string exceptions are deprecated
	anyways and I don't want the warning message to clutter the test
	logs

	* doc/using-pb.xhtml (RemoteInterfaces): document the fact that
	the default name is *not* fully-qualified, necessitating the use
	of __remote_name__ to distinguish between foo.RIBar and baz.RIBar
	* foolscap/remoteinterface.py: same

	* foolscap/call.py (FailureSlicer.getStateToCopy): handle string
	exceptions without exploding, annoying as they are.
	* foolscap/test/test_call.py (TestCall.testFail4): test them

2007-04-27  Brian Warner  <warner@lothar.com>

	* foolscap/broker.py (Broker.freeYourReference._ignore_loss):
	change the way we ignore DeadReferenceError and friends, since
	f.trap is not suitable for direct use as an errback

	* foolscap/referenceable.py (SturdyRef.__init__): log the repr of
	the unparseable FURL, rather than just the str, in case there are
	weird control characters in it

	* foolscap/banana.py (Banana.handleData): rewrite the typebyte
	scanning loop, to remove the redundant pos<64 check. Also, if we
	get an overlong prefix, log it so we can figure out what's going
	wrong.
	* foolscap/test/test_banana.py: update to match

	* foolscap/negotiate.py (Negotiation.dataReceived): if a
	non-NegotiationError exception occurs, log it, since it indicates
	a foolscap coding failure rather than some disagreement with the
	remote end. Log it with 'log.msg' for now, since some of the unit
	tests seem to trigger startTLS errors that flunk tests which
	should normally pass. I suspect some problems with error handling
	in twisted's TLS implementation, but I'll have to investigate it
	later. Eventually this will turn into a log.err.

	* foolscap/pb.py (Tub.keepaliveTimeout): set the default keepalive
	timer to 4 minutes. This means that at most 8 minutes will go by
	without any traffic at all, which should be a reasonable value to
	keep NAT table entries alive. PINGs are only sent if no other
	traffic was received, and they are only one byte long, so the
	traffic overhead should be minimal. Note that we are not turning
	on disconnectTimeout by default: if you want quietly broken
	connections to be disconnected before TCP notices a problem you'll
	need to do tub.setOption("disconnectTimeout", 10*60) or something.

	* foolscap/pb.py: remove an unused import

	* foolscap/pb.py (Tub.generateSwissnumber): always use os.urandom
	to generate the unguessable identifier. Previously we used either
	PyCrypto or fell back to the stdlib 'random' module (which of
	course isn't very random at all). I did it this way originally to
	provide compatibility with python2.3 (which lacked os.urandom):
	now that we require python2.4 or newer, os.urandom is a far better
	source (it uses /dev/random or equivalent).
	* doc/using-pb.xhtml: don't mention PyCrypto now that we aren't
	using it at all.

	* foolscap/negotiate.py (Negotiation.minVersion): bump both min
	and max version to '3', since we've added PING and PONG tokens
	that weren't present before. It would be feasible to accomodate v2
	peers (by adding a Banana flag that refrains from ever sending
	PINGs), but there aren't enough 0.1.2 installations present to
	make this seem like a good idea just now.
	(Negotiation.maxVersion): same
	(Negotiation.evaluateNegotiationVersion3): same
	(Negotiation.acceptDecisionVersion3): same
	* foolscap/test/test_negotiate.py (Future): same

	* foolscap/banana.py (Banana): add keepalives and idle-disconnect.
	The first timeout value says that if we haven't received any data
	for this long, poke the other side by sending them a PING message.
	The other end is obligated to respond with a PONG (both PING and
	PONG are otherwise ignored). If we still haven't heard anything
	from them by the time the second timeout expires, we drop the
	connection.
	(Banana.dataReceived): if we're using keepalives, update the
	dataLastReceivedAt timestamp on every inbound message.
	(Banana.sendPING, sendPONG): new messages and handlers. Both are
	ignored, and serve only to update dataLastReceivedAt.
	* foolscap/tokens.py: add PING and PONG tokens
	* doc/specifications/banana.xhtml: document PING and PONG
	* foolscap/broker.py (Broker.__init__): add keepaliveTimeout and
	disconnectTimeout arguments. Both default to 'None' to disable
	keepalives and disconnects.
	* foolscap/negotiate.py (Negotiation.switchToBanana): copy
	timeouts from the Tub into the new Banana/Broker instance
	* foolscap/pb.py (Tub.setOption): accept 'keepaliveTimeout' and
	'disconnectTimeout' options to enable this stuff.
	* foolscap/test/test_keepalive.py: test it

	* foolscap/pb.py (Tub.brokerClass): parameterize the kind of
	Broker that this Tub will create, to make certain unit tests
	easier to write (allowing them to substitute a custom Broker
	subclass).
	* foolscap/negotiate.py (Negotiation.brokerClass): same
	(Negotiation.initClient): capture the brokerClass here for clients
	(Negotiation.handlePLAINTEXTServer): and here for listeners
	(Negotiation.switchToBanana): use it

2007-04-26  Brian Warner  <warner@lothar.com>

	* README (DEPENDENCIES, INSTALLATION): add docs

2007-04-16  Brian Warner  <warner@lothar.com>

	* foolscap/remoteinterface.py
	(RemoteInterfaceConstraint.checkObject): string-format the object
	inside a tuple, to avoid an annoying logging failure when the
	object in question is actually a tuple

	* foolscap/test/test_gifts.py (ignoreConnectionDone): trap both
	ConnectionDone and ConnectionLost, since it appears that windows
	signals ConnectionLost. Hopefully this will make the unit tests
	pass under windows.

	* foolscap/banana.py (Banana.handleData): when the token prefix is
	too long, log and emit the repr of the prefix string, so somebody
	can figure out where it came from.
	* foolscap/test/test_banana.py (InboundByteStream.testString):
	update to match

2007-04-13  Brian Warner  <warner@lothar.com>

	* foolscap/copyable.py (CopyableSlicer.slice): set self.streamable
	before yielding any tokens, otherwise contained elements that use
	streaming will trigger an exception. Many thanks to
	Ricky (iacovou-AT-gmail.com) for trying out advanced features of
	Foolscap and discovering this problem, I would never have stumbled
	over this one on my own. TODO: we still need unit tests to
	exercise this sort of thing on a regular basis.
	(Copyable2): same thing

	* foolscap/schema.py (_tupleConstraintMaker): redefine what tuples
	mean in constraint specifications. They used to indicate an
	alternative: (int,str) meant accept either an int *or* a string.
	Now tuples indicate actual tuples, so (int,str) means a 2-element
	tuple in which the first element is an int, and the second is a
	string. I don't know what I was thinking back then. If you really
	want to use alternatives, use schema.ChoiceOf instead.
	* foolscap/test/test_schema.py (CreateTest.testMakeConstraint):
	test that tuples mean tuples

	* foolscap/reconnector.py (Reconnector._failed): the old f.trap()
	could sometimes cause the reconnector to stop trying forever.
	Remove that. Thanks to Rob Kinninmont for finding the problem. Add
	new code to log the failure if f.check() indicates that it is a
	NegotiationError, since that's the sort of weird thing that users
	will probably want to see.
	* foolscap/test/test_reconnector.py: add lots of new tests

	* misc/testutils: add tools to do figleaf-based code-coverage
	checks while running unit tests. We have 89.2% coverage! Use
	'make test-figleaf figleaf-output' to see the results.
	* Makefile: new targets for figleaf
	(test): enable 'make test TEST=foolscap.test.test_call' to work
	(test-figleaf): same

	* foolscap/__init__.py: bump revision to 0.1.2+ while between releases
	* misc/{sid|sarge|dapper|edgy|feisty}/debian/changelog: same

2007-04-04  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.1.2
	* misc/{sid|sarge|dapper|edgy|feisty}/debian/changelog: same

	* NEWS: update for new release

2007-04-04  Brian Warner  <warner@lothar.com>

	* misc/feisty/debian/*: add debian packaging support for the
	Ubuntu 'feisty' distribution
	* Makefile: and a way to invoke it
	* misc/edgy/debian/*: same for the 'edgy' distribution
	* MANIFEST.in: include the edgy/feisty files in the source tarball

	* foolscap/test/test_call.py (TestCall.testMegaSchema): add a new
	test to exercise lots of constraint code
	* foolscap/test/common.py: support code for it
	* foolscap/slicers/set.py (SetUnslicer.setConstraint): fix bugs
	discovered as a result
	(SetConstraint.__init__): same

	* foolscap/__init__.py: bump revision to 0.1.1+ while between releases
	* misc/{sid|sarge|dapper}/debian/changelog: same

2007-04-03  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.1.1
	* misc/{sid|sarge|dapper}/debian/changelog: same

	* NEWS: update for new release

2007-04-03  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation): bump both minVersion and
	maxVersion to 2, indicating that this release is not compatible
	with 0.1.0, since the reqID=0 change will cause the first method
	call in either direction (probably a getYourReferenceByName) to
	never receive a response. The handler functions were rearranged a
	bit too.
	* foolscap/test/test_negotiate.py (Future): update to match

	* NEWS: get ready for release

	* foolscap/test/test_pb.py (TestCallable.testLogLocalFailure):
	validate that Tub.setOption("logLocalFailures") actually works
	(TestCallable.testLogRemoteFailure): same

	* foolscap/remoteinterface.py (UnconstrainedMethod): add a
	"constraint" that can be used to mark a method as accepting
	anything and returning anything. This might be useful if you have
	RemoteInterface for most of your application, but there are still
	one or two methods which should not enforce a schema of any sort.
	This mostly defeats the purpose of schemas in the first place, but
	offering UnconstrainedMethod means developers can make the
	schema-or-not decision differently for individual methods, rather
	than for a whole class at a time.
	* foolscap/constraint.py (IRemoteMethodConstraint): document the
	requirements on IRemoteMethodConstraint-providing classes, now that
	there are two of them.
	* foolscap/test/test_call.py (TestCall.testUnconstrainedMethod):
	test it
	* foolscap/test/common.py: add some support code for the test

	* foolscap/referenceable.py
	(RemoteReferenceTracker._handleRefLost): refrain from sending
	decref messages with count=0

	* foolscap/negotiate.py (TubConnectorClientFactory.__repr__):
	include both the origin and the target of the factory

	* foolscap/test/*.py (tearDown): insure that all tests use the
	now-standard stopService+flushEventualQueue teardown procedure, to
	avoid trial complaints about leftover timers and selectables.

	* foolscap/test/test_pb.py (GoodEnoughTub): when crypto is not
	available, skip some tests that really require it. Modify others
	to not really require it.
	* foolscap/test/test_crypto.py: same
	* foolscap/test/test_gifts.py: same
	* foolscap/test/test_loopback.py: same
	* foolscap/test/test_negotiate.py: same

	* foolscap/test/test_*.py (localhost): replace all use of
	"localhost" with "127.0.0.1" to avoid invoking the address
	resolver, which sometimes leaves a cleanup timer running. I think
	the root problem is there's no clean way to interrupt a connection
	attempt which still in the address resolution phase. You can stop
	it, but there's no way to wait for the resolver's cleanup timer to
	finish, which is what we'd need to make Trial happy.
	tcp.BaseClient.resolveAddress does not keep a handle to the
	resolver, so failIfNotConnected cannot halt its timer.
	* foolscap/test/test_zz_resolve.py: removed this test

	* foolscap/crypto.py (_ssl): import SSL goo in a different way to
	appease pyflakes

	* all: fix some pyflakes warnings by checking for the
	importability of foolscap.crypto in a different way

	* foolscap/pb.py (Tub.stopService): when shutting down the Tub,
	make sure all outstanding connections are shut down as well. By
	the time stopService's deferred fires, all of our TCP transports
	should have had their 'connectionLost' methods fired. This is
	specifically to help unit tests that use Trial, which insists upon
	having a clean reactor between tests. With this change, test
	suites should use a tearDown() method that looks like: 'd =
	tub.stopService(); d.addCallback(flushEventualQueue); return d',
	and trial shouldn't complain about foolscap selectables or timers
	being left over.
	(Tub.stopService): also, since Tubs are not currently restartable,
	modify some entry points at shutdown to make sure nobody gets
	confused about why their getReference() doesn't work anymore. Be
	aware that at some point soon, we'll start enforcing the rule that
	the Tub must be started before you can get any connections out of
	it, at which point getReference() will queue requests until
	startService() is called. The idea is that the Tub will not use
	the network at all unless it is running.
	* foolscap/broker.py: drop the connection when shutdown() is called
	* foolscap/negotiate.py (Negotiate): rearrange error reporting and
	connection shutdown. Now errors are stashed and loseConnection()
	is called, but the errors are not reported to negotiationFailed()
	until connectionLost() is fired (which will be after any remaining
	data gets sent out over the wire).
	(TubConnector): the TubConnector reports success once the first
	connection has passed negotiation, but now lives until all of the
	connections are finally closed. It then informs the Tub that it is
	done, so the Tub can forget about it (and possibly notify
	stopService that it can finally complete).

	* foolscap/observer.py (OneShotObserverList): eventual-send -using
	event distributor, following the pattern espoused by Mark Miller's
	"Concurrency Among Strangers" paper. Many thanks to AllMyData.com
	for contributing this class.
	* foolscap/test/test_observer.py: tests for it

2007-03-22  Brian Warner  <warner@lothar.com>

	* foolscap/constraint.py (StringConstraint): add a regexp= argument
	* foolscap/test/test_schema.py (ConformTest.testString): test it

	* foolscap/test/test_banana.py (TestBananaMixin.shouldDropConnection):
	fix a pyflakes warning
	* foolscap/call.py: same, don't fall back to plain StringIO if
	cStringIO is unavailable
	* foolscap/debug.py: same
	* foolscap/storage.py: same

	* foolscap/slicers/list.py (ListConstraint): add a minLength=
	argument, fix maxLength=None
	* foolscap/test/test_schema.py (ConformTest.testList): test it

	* foolscap/constraint.py (StringConstraint): add a minLength=
	argument
	* foolscap/test/test_schema.py (ConformTest.testString): test it

	* foolscap/slicers/set.py (BuiltinFrozenSetSlicer): add slicer for
	the builtin 'frozenset' type that appeared in python2.4
	(SetConstraint): provide a constraint for sets
	* foolscap/schema.py (SetOf): add an alias
	* foolscap/test/test_schema.py (ConformTest.testSet): test it

2007-03-20  Brian Warner  <warner@lothar.com>

	* foolscap/banana.py (Banana.outgoingVocabTableWasReplaced): remove
	verbose debug message, not really needed anymore

	* foolscap/ipb.py (IRemoteReference.callRemoteOnly): new method to
	invoke a remote method without waiting for a response. Useful for
	certain messages where we really don't care whether the far end
	receives them or not.
	* foolscap/referenceable.py (RemoteReference.callRemoteOnly):
	implement it
	(TheirReferenceUnslicer.ackGift): use it
	* foolscap/broker.py (Broker.initBroker): use reqID=0 to mean "we
	don't want a response". Note that this is a compatibility barrier:
	older endpoints which use reqID=0 for the first message will not
	get a response. All subsequent messages will be ok, though.
	(Broker._callFinished): don't send a response if reqID=0
	(Broker.callFailed): don't send an error if reqID=0
	* foolscap/call.py (InboundDelivery.logFailure): fix arg logging
	(CallUnslicer.receiveChild): don't create an activeLocalCalls
	entry if reqID=0
	* foolscap/test/test_call.py (TestCallOnly.testCallOnly): test it
	(TestCall._testFailWrongReturnLocal_1): update expectations,
	now that reqIDs start at 1 instead of 0
	* foolscap/test/common.py (TargetMixin.poll): new support code

	* foolscap/referenceable.py: add Referenceable to
	schema.constraintMap, so that RemoteInterfaces can use 'return
	Referenceable' to indicate that they return a Referenceable of any
	sort. This is like using 'return RIFoo' to indicate that the
	method returns a Referenceable that implements RIFoo, but without
	the specific interface requirement.
	* foolscap/remoteinterface.py (RemoteInterfaceConstraint): support
	this by skipping the interface check if self.interface=None
	* foolscap/test/test_schema.py (CreateTest): test it
	* foolscap/test/test_interfaces.py (Types): update test to match,
	since the error messages changed
	* foolscap/test/common.py: more test support changes

2007-03-19  Brian Warner  <warner@lothar.com>

	* foolscap/ipb.py (IRemoteReference): new interface ..
	* foolscap/referenceable.py (RemoteReferenceOnly): .. implemented here
	* foolscap/remoteinterface.py
	(RemoteInterfaceConstraint.checkObject): remove a circular import
	by using IRemoteReference to detect RemoteReference instances,
	rather than using isinstance().
	* foolscap/test/test_schema.py (Interfaces): test it

	* everything: massive Constraint refactoring. Primitive
	constraints (StringConstraint, IntegerConstraint, etc) are now in
	foolscap/constraint.py, while opentype-specific constraints like
	ListConstraint and BooleanConstraint are in the same module that
	defines the associated Slicer. Remote method constraints are in
	remoteinterface.py and copyable.py, FailureConstraint is in
	call.py . A new foolscap/constraint.py module contains the base
	classes but is careful not to import much else. foolscap/schema.py
	contains a reference to all constraints, so that user code can get
	at them conveniently. Tests were updated to import from the new
	places. Some circular imports were resolved. zope.interface
	adaptation has been used to assist with the conversion from the
	"shorthand" forms of constraint specification into the full form
	(i.e. converting x=str into x=StringConstraint()), specifically
	IConstraint(shorthand) will return a Constraint instance.

	* foolscap/__init__.py: bump revision to 0.1.0+ while between releases
	* misc/{sid|sarge|dapper}/debian/changelog: same

2007-03-15  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.1.0
	* misc/{sid|sarge|dapper}/debian/changelog: same

	* README: update for new release
	* NEWS: update for new release

2007-02-16  Brian Warner  <warner@lothar.com>

	* foolscap/eventual.py (_SimpleCallQueue._turn): retire all
	pending eventual-send messages before returning control to the
	reactor, rather than doing exactly one event per reactor turn.
	This seems likely to help avoid starvation, as we now finish as
	much work as possible before accepting IO (which might cause more
	work to be added to our queue), and probably makes the interaction
	between eventual-send and DelayedCalls a bit more consistent.
	Thanks to Rob Kinninmont for the suggestion.

2007-02-08  Brian Warner  <warner@lothar.com>

	* foolscap/test/test_pb.py: move TestCall out to..
	* foolscap/test/test_call.py: .. a new test file

	* foolscap/test/test_negotiate.py (BaseMixin.tearDown): add a
	100ms stall between shutting down all the Tubs and actually
	finishing the test. This seems to be enough to stop the occasional
	test failures that probably occur because TCP connections that
	we've dropped haven't finished signalling the other end (also in
	our process) that they've been closed.

2007-01-30  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Tub): add certFile= argument, to allow the Tub
	to manage its own certificates. This argument provides a filename
	where the Tub should read or write its certificate. If the file
	exists, the Tub will read the certificate data from there. If not,
	the Tub will generate a new certificate and write it to the file.
	* foolscap/test/test_tub.py: test it
	* doc/using-pb.xhtml: document certFile=
	* doc/listings/pb2server.py: use certFile= in the example

2007-01-24  Brian Warner  <warner@lothar.com>

	* foolscap/crypto.py (MyOptions._makeContext.alwaysValidate): add
	code to ignore two additional OpenSSL certificate validation
	errors: X509_V_ERR_CERT_NOT_YET_VALID (9) and
	X509_V_ERR_CERT_HAS_EXPIRED (10). Foolscap uses certificates very
	differently than web sites, and it is exceedingly common to start
	using a cert mere seconds after creating it. If there is any
	significant clock skew between the two systems, then insisting
	that the cert's "valid after X" time is actually in the past will
	cause a lot of false errors.

2007-01-22  Brian Warner  <warner@lothar.com>

	* .darcs-boringfile: ignore files that are generated by distutils
	when we make a source release (dist/*) and when making a debian
	package (build/* and the debian install directory).

	* foolscap/__init__.py: bump revision to 0.0.7+ while between releases
	* misc/{sid|sarge|dapper}/debian/changelog: same

2007-01-16  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.0.7
	* misc/{sid|sarge|dapper}/debian/changelog: same

	* NEWS: update for 0.0.7

2007-01-16  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Tub.getBrokerForTubRef): special-case an attempt
	to connect to a tub with an ID equal to our own, by attaching a
	Broker to a special LoopbackTransport that delivers serialized
	data directly to a peer without going through a socket.
	* foolscap/broker.py (LoopbackTransport): same
	(Broker.setTub): refactor some code out of negotiate.py
	* foolscap/negotiate.py (Negotiation.switchToBanana): same
	(Negotiation.loopbackDecision): new method to determine params for
	a loopback connection
	* foolscap/test/test_loopback.py: enable all tests, add a check to
	make sure we can connect to ourselves twice

	* foolscap/referenceable.py (RemoteReferenceTracker.getRef): the
	weakref this holds may have become stale, so check that we both
	have self.ref *and* that self.ref() is not None to decide whether
	we must re-create the RemoteReference. This fixes a bug in which
	two calls to Tub.getReference() for the same URL would result in
	the second call getting None.
	(RemoteReferenceTracker._handleRefLost): only send a decref
	message if we haven't already re-created the RemoteReference
	* foolscap/test/test_pb.py (TestService.testConnect3): modify this
	test to validate the 'call Tub.getReference() twice' bug is fixed

2007-01-15  Brian Warner  <warner@lothar.com>

	* foolscap/test/test_loopback.py (ConnectToSelf): Add tests to
	validate that we can connect to our own Tub properly. This test
	does not yet pass for authenticated Tubs: the negotiation hangs
	until the 30 second timeout is reached. To fix this requires
	special-casing such connections to use a different kind of Broker,
	one that wires transport.write to eventual(rcvr.dataReceived) and
	skips negotiation completely.

2007-01-10  Brian Warner  <warner@lothar.com>

	* doc/using-pb.xhtml: fix some "pb" references to mention
	"Foolscap" instead
	* doc/schema.xhtml: same

2007-01-09  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Listener.removeTub): disownServiceParent is not
	guaranteed to return a Deferred, so don't try to make removeTub do
	so either. I saw a failure related to this, but was unable to
	analzye it well enough to reproduce it or write a test case.
	(Tub.stopListeningOn): tolerate removeTub returning synchronously
	(Tub.stopService): same

2007-01-04  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation.dataReceived): when sending
	an error message to the far end inside the decision block, make
	sure the error text itself has no newlines, since that would break
	the format of the block, and probably cause all sorts of
	confusion.
	* foolscap/ipb.py (IRemotelyCallable.doRemoteCall): remote calls now
	accept positional args

2007-01-04  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: bump revision to 0.0.6+ while between
	releases
	* misc/{sid|sarge|dapper}/debian/changelog: same

2006-12-18  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.0.6
	* misc/{sid|sarge|dapper}/debian/changelog: same

2006-12-18  Brian Warner  <warner@lothar.com>

	* misc/{sid|sarge|dapper}/debian/rules: include copyable.xhtml

	* NEWS: update for 0.0.6

	* foolscap/negotiate.py (Negotiation): Send less data. When
	sending a range (both for the fundamental banana negotiation
	version and for the initial vocab table index), send it in a
	single line with "0 1" rather than two separate min and max lines.
	This brings the hello message down to about 105 bytes and improves
	the benefit of using a negotiated initial-vocab-table-range rather
	than an early (but post-negotiation) SET-VOCAB banana sequence.

	* foolscap/schema.py: add RemoteInterfaceConstraints. This works
	by declaring an argument as, e.g., RIFoo, which means that this
	argument must be passed a RemoteReference that is connected to a
	remote Referenceable which implements RIFoo. This works as a
	return value constraint too.
	(Constraint.checkObject): add inbound=
	argument to this method, so RemoteInterfaceConstraint can work
	properly
	(InterfaceConstraint): split this into local and remote forms
	(LocalInterfaceConstraint): only check real local objects, not
	RemoteReferences. This isn't really useful yet, but eventually
	schemas will turn into proper local Guards and then it will be.
	(RemoteInterfaceConstraint): only check RemoteReferences. The
	check performed must be different on inbound and outbound (since
	we'll see a RemoteReference when inbound=True, and a Referenceable
	when inbound=False).
	(makeConstraint): distinguish between Interfaces and
	RemoteInterfaces, so we can figure out whether to use
	LocalInterfaceConstraint or RemoteInterfaceConstraint
	(callable): get rid of this, the functionality has been absorbed
	into RemoteMethodSchema.initFromMethod
	* foolscap/broker.py (Broker._doCall): use inbound= argument
	(Broker._callFinished): same
	* foolscap/referenceable.py (RemoteReference._callRemote): same
	* foolscap/slicer.py (ReferenceUnslicer.receiveChild): same
	* foolscap/test/test_schema.py: same
	* foolscap/test/test_interfaces.py: rearrange, add tests for
	RemoteInterfaces.
	(LocalTypes): there are tests for Interfaces too, but without local
	Guards they're disabled for now.
	* foolscap/test/common.py: refactoring

	* foolscap/schema.py (makeConstraint): map None to Nothing(),
	which only accepts None. This is pretty handy for methods which
	are always supposed to return None.

	* foolscap/schema.py (RemoteMethodSchema.checkResults): don't
	annotate any Violations here.. leave that up to the caller
	* foolscap/broker.py (Broker._callFinished): update the annotation
	* foolscap/test/test_pb.py: update to match

	* foolscap/tokens.py (Violation.prependLocation): add new methods
	to Violations for easier annotation of where they occurred
	(Violation.appendLocation): same
	(Violation.__str__): remove the "at" from the location text
	* foolscap/test/test_pb.py: update to match

	* foolscap/broker.py (Broker._callFinished): if the outbound
	return value violates the schema, annotate the Violation to
	indicate the object and method that was responsible.

2006-12-15  Brian Warner  <warner@lothar.com>

	* foolscap/call.py (CopiedFailure): clean up a bit, make it match
	the current Failure class better

	* doc/using-pb.xhtml: document positional arguments

	* foolscap/call.py: pass both positional and keyword arguments to
	remote methods. Previously only keyword arguments were accepted.
	This is a pretty far-reaching change, and introduces a
	compatibility barrier.
	(ArgumentSlicer): send both positional args and kwargs in a
	separate container
	(CallSlicer): move arg-sending out of CallSlicer
	(InboundDelivery.isRunnable): make InboundDelivery itself
	responsible for determining when it is runnable, instead of
	leaving that up to the CallUnslicer. The InboundDelivery is always
	referenceable, making the resulting object delivery simpler.
	(ArgumentUnslicer): move arg-receiving out of CallUnslicer. All of
	the schema-checking takes place here. Simplify the are-we-ready
	tests.
	(CallUnslicer): most of the code has moved out. The (call)
	sequence is now ('call', reqID, objID, methname, (args)).
	* foolscap/broker.py (Broker.scheduleCall): simplify, allow posargs
	* foolscap/referenceable.py (Referenceable.doRemoteCall): deliver
	posargs to the target method as well as kwargs
	(RemoteReference): same, stop trying to pre-map posargs into kwargs,
	no longer require a RemoteInterface to use posargs
	* foolscap/vocab.py (vocab_v1): add 'arguments' to the v1 vocab
	list. This is a compatibilty barriers, and changes like this are
	only allowed between releases. Once 0.0.6 is out we should leave
	the v1 list alone and make any additions to v2 instead.
	* foolscap/schema.py (RemoteMethodSchema): allow posargs, deal
	correctly with a mixture of posargs and kwargs
	* foolscap/test/test_schema.py (Arguments): test the
	RemoteMethodSchema class
	* foolscap/test/test_pb.py (TestCall.testCall1a): new tests of
	posargs and mixed posargs/kwargs
	(TestService.tearDown): use flushEventualQueue for cleanup
	* foolscap/test/test_interfaces.py (TestInterface): change a few
	things to match RemoteMethodSchema's new interfaces

	* foolscap/eventual.py (flushEventualQueue): allow this method to
	accept a single argument, which it ignores. This enables it to be
	used easily as a Deferred callback/errback, such as in a Trial
	tearDown method. The recommended usage is: d = clean_stuff();
	d.addBoth(flushEventualQueue); return d

2006-12-11  Brian Warner  <warner@lothar.com>

	* foolscap/vocab.py: add code to negotiate an initial set of words
	with which to pre-fill the VOCAB token list. Each side proposes a
	range and they use the highest common index (and they exchange a
	short hash of the list itself to guard against disagreements).
	This serve to compress the protocol traffic by maybe 50% over the
	longer run.
	* foolscap/negotiate.py: send the 'initial-vocab-table-min' and
	'-max' keys in the offer, and 'initial-vocab-table-index' in the
	decision (and in the Banana params)
	* foolscap/broker.py (Broker.__init__): populate the table
	* foolscap/banana.py (Banana.populateVocabTable): new method

	* foolscap/test/test_banana.py (Sliceable.testAdapter): todo items

	* foolscap/referenceable.py
	(RemoteReferenceOnly.notifyOnDisconnect): document this method.
	* foolscap/broker.py (Broker.shutdown): cancel all disconnect
	watchers upon shutdown
	* foolscap/pb.py (Tub.stopService): same

	* foolscap/negotiate.py (Negotiation.evaluateHello): if we spot an
	<=0.0.5 peer, mention that fact in our error message, to
	distinguish this case from some completely non-Foolscapish
	protocol trying to talk to us.

2006-12-10  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (TubConnectorClientFactory.__repr__):
	annotate the string form to include which Tub we're connecting to.
	This makes the default factory's "BlahFactory Starting" log
	messages more interesting to look at.
	* foolscap/referenceable.py (TubRef.getTubID): support method
	(NoAuthTubRef.getTubID): same

2006-12-01  Brian Warner  <warner@lothar.com>

	* foolscap/referenceable.py (RemoteReference.callRemote): use
	defer.maybeDeferred to rearrange and simplify. Clarify the
	comments about the various phases of commitment.

	* foolscap/call.py (AnswerUnslicer.checkToken): when re-raising an
	exception, use bareword 'raise' rather than explicitly re-raising
	the same exception instance with 'raise v'. Both forms get the
	right instance, but the latter loses the earlier stack trace.
	* foolscap/schema.py (RemoteMethodSchema.checkResults): same
	(RemoteMethodSchema.checkAllArgs): same
	* foolscap/referenceable.py (RemoteReference.callRemote): same

	* foolscap/test/test_interfaces.py (TestInterface.testStack): new
	test to verify that the Failure you get when you violate outbound
	method arguments actually includes the call to callRemote.

	* foolscap/schema.py (StringConstraint.checkObject): make the Violation
	message more useful
	(InterfaceConstraint.checkObject): same, by printing the repr() of the
	object that didn't meet the constraint. I'm not sure if this could be
	considered to leak sensitive information or not.
	(ClassConstraint.checkObject): same
	(RemoteMethodSchema.checkAllArgs): record which argument caused the
	problem in the Violation
	* foolscap/referenceable.py (RemoteReference.callRemote): add
	RemoteInterface and method name to the Violation when a caller
	violates their outbound constraint

	* foolscap/tokens.py (Violation.setLocation,getLocation): make it
	easier to modify an existing location value

	* foolscap/test/test_interfaces.py (TestInterface.testFail): verify
	that RemoteFailures pass a StringConstraint schema

	* foolscap/test/test_copyable.py: remove unused imports, from pyflakes
	* foolscap/test/test_pb.py: same
	* foolscap/test/test_reconnector.py: same
	* foolscap/test/test_registration.py: same

	* foolscap/test/test_interfaces.py: split the RemoteInterface
	tests out to a separate file
	* foolscap/test/test_pb.py: split them from here
	* foolscap/test/common.py: factor out some common utility classes

2006-11-30  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation.dataReceived): when sending
	an error block, set banana-decision-version to '1' so the
	recipient knows that it's safe to interpret the 'error' key.
	Thanks to Rob Kinninmont for the catch.

2006-11-27  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation._evaluateNegotiationVersion1):
	ignore extra keys in the offer, since a real v2 (and beyond) offer
	will have all sorts of extra keys.
	* foolscap/test/test_negotiate.py (NegotiationV2): test it by
	putting extra keys in the offer

2006-11-26  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation): change negotiation
	protocol: now each end sends a minVersion/maxVersion pair, using
	banana-negotiation-min-version and banana-negotiation-max-version,
	indicating that they can handle all versions between those
	numbers, inclusive. The deciding end finds the highest version
	number that fits in the ranges of both ends, and includes it in
	the banana-decision-version key of the decision block. This is an
	incompatible protocol change, but should make it easier (i.e.
	possible) to have compatible protocol changes in the future.
	Thanks to Zooko for suggesting this approach.
	(Negotiation.evaluateNegotiationVersion1): each negotiation
	version gets is own methods
	(Negotiation.acceptDecisionVersion1): same
	(TubConnectorClientFactory.buildProtocol): allow the Tub to make
	us use other Negotiation classes, for testing
	* foolscap/pb.py (Listener.__init__): same, use the class from the
	Tub that first caused the Listener to be created
	* foolscap/broker.py (Broker.__init__): record the
	banana-decision-version value, so tests can check it
	* foolscap/test/test_negotiate.py (Future): test it

2006-11-17  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py: remove unused and dodgy urlparse stuff

	* doc/using-pb.xhtml: move and expand the section on Copyable and
	other pass-by-copy things into a new file
	* doc/copyable.xhtml: new document. Thanks to Ricky Iacovou for
	the registerCopier examples.
	* doc/listings/copyable-{receive|send}.py: new examples
	* doc/stylesheet.css, doc/stylesheet-unprocessed.css
	* doc/template.tpl: docs utilities
	* Makefile: add 'make docs' target

	* foolscap/__init__.py: export registerCopier and
	registerRemoteCopyFactory

	* foolscap/copyable.py (Copyable): The new preferred Copyable
	usage is to have a class-level attribute named "typeToCopy" which
	holds the unique string. This must match the class-level
	"copytype" attribute of the corresponding RemoteCopy class.
	Copyable subclasses (or ICopyable adapters) may still implement
	getTypeToCopy(), but the default just returns self.typeToCopy .
	Most significantly, we no longer automatically use the
	fully-qualified classname: instead we *require* that the class
	definition include "typeToCopy". Feel free to use any stable and
	globally-unique string here.
	(RemoteCopyClass): Require that RemoteCopy subclasses set their
	"copytype" attribute, and use it for auto-registration. These
	subclasses can still use "copytype=None" to inhibit
	auto-registration. They no longer auto-register with the
	fully-qualified classname.
	* foolscap/referenceable.py (SturdyRef): match this change
	* foolscap/test/test_copyable.py: same

2006-11-16  Brian Warner  <warner@lothar.com>

	* foolscap/negotiate.py (Negotiation.dataReceived): include the
	error message in the '500 Internal Server Error' string.
	(Negotiation.handlePLAINTEXTClient): include the full '500
	Internal Server Error' string in the reported exception. These two
	changes make it easier to spot mismatched TubIDs. Thanks to Rob
	Kinninmont for the suggestion.

2006-11-14  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: bump revision to 0.0.5+ while between
	releases
	* misc/{sid|sarge|dapper}/debian/changelog: same

2006-11-04  Brian Warner  <warner@lothar.com>

	* NEWS: update for 0.0.5
	* foolscap/__init__.py: release Foolscap-0.0.5
	* misc/{sid|sarge|dapper}/debian/changelog: same
	* MANIFEST.in: add debian packaging files to source tarball

2006-11-01  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Tub.setOption): new API to set options. Added
	logRemoteFailures and logLocalFailures, which cause failed
	callRemotes to be sent to the twisted log via log.msg . The
	defaults are False, which means that failures are only reported
	through the caller's Deferred.errback .

	Setting logRemoteFailures to True means that the client's log will
	contain a record of every callRemote that it sent to someone else
	that failed on the far side. This can be implemented on a
	per-callRemote basis by just doing d.addErrback(log.err)
	everywhere, but often there are reasons (like debugging) for
	logging failures that are completely independent of the desired
	error-handling path. These log messages have a REMOTE: prefix to
	make it very clear that the stack trace being shown is *not*
	occurring on the local system, but rather on some remote one.

	Setting logLocalFailures to True means that the server's log will
	contain a record of every callRemote that someone sent to it which
	failed on that server. This cannot be implemented with
	addErrbacks, since normally the server does not care about the
	methods it is running for other people's benefit. This option is
	purely for debugging purposes. These log messages have a LOCAL:
	prefix to make it clear that the stack trace is happening locally,
	but on behalf of some remote caller.

	* foolscap/call.py (PendingRequest.fail): improve the logging,
	make it conditional on logRemoteFailures, add the REMOTE: prefix
	(InboundDelivery): put more information into the InboundDelivery,
	move logLocalFailures logging into it
	(CallUnslicer.receiveClose): put the .runnable flag on the
	InboundDelivery object instead of on the CallUnslicer

	* foolscap/broker.py (Broker): pass the InboundDelivery around
	instead of the CallUnslicer that it points to.
	(Broker.callFailed): Add logLocalFailures checking here.


	* foolscap/reconnector.py: oops, add missing import that would break
	any actual reconnection attempts

2006-10-31  Brian Warner  <warner@lothar.com>

	* misc/sarge/debian/control: add sarge packaging
	* misc/dapper/debian/control: update dependencies, add Recommends
	on pyopenssl
	* misc/sid/debian/control: same
	* Makefile: add 'debian-sarge' target

	* misc/dapper/debian: move debian packaging up a level
	* misc/sid/debian: same
	* Makefile: same

	* foolscap/__init__.py (__version__): bump to 0.0.4+ while between
	releases
	* misc/debs/sid/debian/changelog: same
	* misc/debs/dapper/debian/changelog: same

2006-10-26  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.0.4
	* misc/debs/sid/debian/changelog: same
	* misc/debs/dapper/debian/changelog: same

2006-10-26  Brian Warner  <warner@lothar.com>

	* setup.py: fix project URL

	* MANIFEST.in: include misc/debs/* in the source tarball

	* NEWS: update for 0.0.4

	* foolscap/test/test_reconnector.py: verify that the Reconnector's
	callbacks are properly interleaved with any notifyOnDisconnect
	callbacks the user might have registered. A Reconnector cb that
	uses notifyOnDisconnect should see a strictly-ordered sequence of
	connect, disconnect, connect, disconnect.

2006-10-25  Brian Warner  <warner@lothar.com>

	* foolscap/referenceable.py
	(RemoteReferenceOnly.notifyOnDisconnect): accept args/kwargs to
	pass to the callback. Return a marker that can be passed to
	dontNotifyOnDisconnect() to de-register the callback.
	* foolscap/broker.py (Broker.notifyOnDisconnect): same
	(Broker.connectionLost): fire notifyOnDisconnect callbacks in a
	separate turn, using eventually(), so that problems or
	side-effects in one call cannot affect other calls or the
	connectionLost process
	* foolscap/test/test_pb.py (TestCall.testDisconnect4): test it

	* foolscap/pb.py (Tub.registerReference): undo that, make
	registerReference *always* create a strongref to the target, but
	split some of the work out to an internal function which makes the
	weakrefs. Tub.registerReference() is the API that application code
	uses to publish an object (make it reachable) *and* have the Tub
	keep it alive for you. I'm not sure I can think of a use case for
	making it reachable but *not* wanting the Tub to keep it alive. If
	you want to make it reachable but still ephemeral, just pass it
	over the wire.
	(Tub._assignName): new method to make weakrefs and assign names.
	(Tub.getOrCreateURLForReference): renamed from getURLForReference.
	Changed to assign a name if possible and one didn't already exist.
	BEHAVIOR CHANGE: This causes *all* objects passed over the wire,
	whether explicitly registered or just implicitly passed along, to
	be shareable as gifts (assuming the Tub is reachable and has a
	location, of course).
	* foolscap/referenceable.py (ReferenceableTracker.getURL): update

	* foolscap/test/test_registration.py (Registration.testWeak): use
	_assignName instead of registerReference
	* foolscap/test/test_gifts.py (Gifts.testOrdering): test it

2006-10-25  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Tub.registerReference): add a strong= argument
	which means the Tub should keep the registered object alive. If
	strong=False, the tub uses a weakref, so that when the application
	and all remote peers forget about the object, the Tub will too.
	strong= defaults to True to match the previous behavior, but this
	might change in the future, and/or it might become a property to
	be set on the Tub.
	* foolscap/test/test_registration.py: new tests for it
	* foolscap/test/test_pb.py (TestService.testStatic): disable this
	test, since static data (like tuples) are not weakreffable. The
	registration of static data is an outstanding issue.

	* foolscap/pb.py (Tub.connectTo): provide a new method, sets up a
	repeating connection to a given url (with randomized exponential
	backoff) that will keep firing a callback each time a new
	connection is made. This is the foolscap equivalent of
	ReconnectingClientFactory, and is the repeating form of
	getReference(). Thanks to AllMyData.com for sponsoring this work.
	* foolscap/reconnector.py (Reconnector): implement it here
	* foolscap/test/test_reconnector.py: test it

	* doc/using-pb.xhtml: update to reflect that we now have secure
	PBURLs and TubIDs, and that methods are delivered in-order (at
	least within a Tub-to-Tub connection) even in the face of gifts.

	* misc/debs/dapper/debian/rules (binary-indep): remove obsolete
	reference to the old python-twisted-pb2 package

	* foolscap/referenceable.py (YourReferenceSlicer.slice): assert
	that we actually have a URL to give out, since otherwise the error
	will confusingly show up on the far end (as a Violation). This
	occurs when we (as Alice) try to introduce Carol to a Bob that was
	not explicitly registered in Bob's Tub, such that Bob does not
	have a URL to give out.

	* foolscap/pb.py (Tub): tubID is no longer a parameter to Tub,
	since it is always computed from the certificate
	(UnauthenticatedTub): but it *is* a parameter here, since there
	is no certificate

	* foolscap/broker.py (Broker.getMyReferenceByCLID): relax the
	assertion to (int,long), since eventually clids will overrun a
	31-bit integer. Thanks to Rob Kinninmont for the catch.
	(Broker.remote_decref): same

2006-10-10  Brian Warner  <warner@lothar.com>

	* misc/debs: add some debian packaging, separate directories for
	sid and dapper because sid has pycentral and dapper is still in
	the versioned-python-package era
	* Makefile: simple Makefile to remind me how to create .debs

2006-10-05  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: bump to 0.0.3+ while between releases

2006-10-05  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.0.3
	* NEWS: update for 0.0.3 release

2006-10-05  Brian Warner  <warner@lothar.com>

	* foolscap/test/test_gifts.py (Gifts): split out the Introduction
	tests from test_pb.py
	(Gifts.testOrdering): test the ordering of messages around a gift.
	Doing [send(1), send(2, carol), send(3)] should result in Bob seeing
	[1, (2,carol), 3] in that order. Before the recent ordering fix,
	the presence of the gift would delay message delivery, resulting in
	something like [1, 3, (2,carol)]
	* foolscap/test/test_pb.py: same

	* foolscap/call.py (CallUnslicer): fix ordering of message
	delivery in the face of Gifts. Each inbound method call gets
	unserialized into an InboundDelivery/CallUnslicer pair, which gets
	put on a queue. Messages get pulled off the queue in order, but
	only when the head of the queue is ready (i.e. all of its
	arguments are available, which means any pending Gifts have been
	retrieved).
	(InboundDelivery): same
	(CallUnslicer.describe): stop losing useful information
	* foolscap/broker.py (Broker.doNextCall): add inboundDeliveryQueue
	to implement all this
	* foolscap/test/test_pb.py (TestCall.testFailWrongArgsRemote1):
	match the change to CallUnslicer.describe

	* foolscap/referenceable.py (TheirReferenceUnslicer.receiveClose):
	don't bother returning ready_deferred, since we're returning an
	unreferenceable Deferred anyway.

	* foolscap/test/test_pb.py (Test3Way): put off the check that
	Alice's gift table is empty until we're sure she's received the
	'decgift' message. Add a note about a race condition that we have
	to work around in a weird way to avoid spurious test failures
	until I implement sendOnly (aka callRemoteOnly).

2006-10-04  Brian Warner  <warner@lothar.com>

	* foolscap/test/test_banana.py (ThereAndBackAgain.testIdentity):
	use an actual tuple. Obviously I wasn't thinking when I first
	wrote this and tried to use "(x)" to construct a one-item tuple.

2006-10-02  Brian Warner  <warner@lothar.com>

	* everything: fix most of the pyflakes warnings. Some of the
	remaining ones are actual bugs where I need to finish implementing
	something.

	* foolscap/slicers/*.py: move most Slicers/Unslicers out to separate
	files, since slicer.py was way too big
	* foolscap/slicers/allslicers.py: new module to pull them all in.
	banana.py imports this to make sure all the auto-registration hooks
	get triggered.
	* everything: rearrange imports to match
	* setup.py: add new sub-package

2006-10-01  Brian Warner  <warner@lothar.com>

	* foolscap/slicer.py: rearrange the internals, putting the
	corresponding Slicer and Unslicer for each type next to each other

	* foolscap/slicer.py: move all "unsafe" Slicers and Unslicers out to
	storage.py where it belongs
	* foolscap/storage.py: same
	* foolscap/test/test_banana.py: fix some imports to match
	* foolscap/test/test_pb.py: same

	* foolscap/slicer.py (ReplaceVocabSlicer): clean up VOCAB
	handling: add the ('add-vocab') sequence to incrementally add to
	the receiving end's incomingVocabulary table, fix the race
	condition that would have caused problems for strings that were
	serialized after the setOutgoingVocabulary() call was made but
	before the ('set-vocab') sequence was actually emitted. Lay the
	groundwork for adaptive tokenization and negotiated vocab table
	presets. Other classes involved are AddVocabSlicer,
	AddVocabUnslicer, and ReplaceVocabUnslicer.
	(BananaUnslicerRegistry): handle the add-vocab and set-vocab
	sequences with a registry rather than special-casing them.
	* foolscap/storage.py (UnsafeRootUnslicer): same, add the
	BananaUnslicerRegistry

	* foolscap/banana.py (setOutgoingVocabulary): make it safe
	to call this function at any time, as it merely schedules
	an update. Change the signature to accept a list of strings
	that should be tokenized rather than expecting the caller to
	choose the index values as well.
	(addToOutgoingVocabulary): new function to tokenize a single
	string, also safe to call at any time
	(outgoingVocabTableWasReplaced):
	(allocateEntryInOutgoingVocabTable):
	(outgoingVocabTableWasAmended): new functions for use by the
	Slicers that are sending the 'set-vocab' and 'add-vocab' sequences
	(Banana.maybeVocabizeString): reserve a place for adaptize
	tokenizing
	* foolscap/test/test_banana.py: match the changes


	* foolscap/broker.py: s/topRegistry/topRegistries/, since it is
	actually a list of Registries. Same for openRegistry and
	openRegistries
	* foolscap/slicer.py: same
	* foolscap/storage.py: same
	* foolscap/test/test_banana.py: same

	* foolscap/slicer.py (BuiltinSetSlicer): use a different test to
	look for python < 2.4, one which doesn't make pyflakes complain
	about using __builtins__

2006-09-30  Brian Warner  <warner@lothar.com>

	* foolscap/promise.py (Promise): implement a simpler syntax, at
	the encouragement of Zooko and others: now p.foo(args) does an
	eventual-send. This is a simpler form of send(p).foo(args) . Added
	_then and _except methods to do simple callback/errback handling.
	You can still do send() and sendOnly() on either immediate values
	or Promises: this shortcut only helps with send() on a Promise.
	You can still do when() on a Promise, which is more flexible
	because it returns a Deferred. The new syntax gives you a more
	dataflow-ish style of coding, which might be confusing in some
	ways but can also make the overall code much much easier to read.
	* foolscap/test/test_promise.py: update tests

	* foolscap/test/common.py (HelperTarget.remote_defer): replace
	callLater(0) with fireEventually()
	* foolscap/test/test_banana.py (ErrorfulSlicer.next): same
	(EncodeFailureTest.tearDown): use flushEventualQueue() for cleanup

	* foolscap/crypto.py (CertificateError): In Twisted >2.5, this
	exception is defined in twisted.internet.error, and it is
	sometimes raised by the SSL transport (in getPeerCertificate), and
	we need to catch it. In older versions, we define it ourselves
	even though it will never be raised, so that the code which
	catches it doesn't have to have weird conditionals.
	* foolscap/negotiate.py (Negotiation.handleENCRYPTED): catch the
	CertificateError exception (which indicates that we have an
	encrypted but unauthenticated connection: the other end did not
	supply a certificate). In older versions of twisted's SSL code,
	this was just indicated by having getPeerCertificate() return
	None.

	* foolscap/test/test_negotiate.py: re-enable all negotiation tests

	* foolscap/pb.py (UnauthenticatedTub): change the API and docs to
	refer to "Unauthenticated" tubs rather than "Unencrypted" ones,
	since that's really the choice you get to make. We use encrypted
	connections whenever possible; what you get to control is whether
	we use keys to provide secure identification and introduction.
	* foolscap/__init__.py: same, export UnauthenticatedTub instead of
	UnencryptedTub
	* foolscap/negotiate.py: same
	* foolscap/referenceable.py: same
	* foolscap/test/test_negotiate.py: same
	* doc/listings/pb1server.py: update examples to match
	* doc/using-pb.xhtml: same

2006-09-26  Brian Warner  <warner@lothar.com>

	* foolscap/pb.py (Tub): rename PBService to Tub, make it always
	be encrypted
	(UnencryptedTub): new class for unencrypted tubs
	* all: fix everything else (code, docs, tests) to match
	* foolscap/ipb.py (ITub): new interface to mark a Tub

2006-09-24  Brian Warner  <warner@lothar.com>

	* foolscap/referenceable.py (RemoteReferenceTracker._refLost): now
	that we have eventually(), use it to avoid the ugly bug-inducing
	indeterminacies that result from weakref callbacks being fired in
	the middle of other operations.

	* foolscap/promise.py (Promise._resolve): I think I figured out
	chained Promises. In the process, I made it illegal to call
	_break after the Promise has already been resolved. This also
	means that _resolve() can only be called once. We'll figure
	out breakable Far references later.
	* foolscap/test/test_promise.py (Chained): tests for them

	* foolscap/broker.py (Broker.getRemoteInterfaceByName): fix a bunch
	of typos caught by pyflakes. Left a couple of ones in there that I
	haven't figured out how to fix yet.
	* foolscap/slicer.py (InstanceUnslicer.receiveChild): same
	* foolscap/schema.py (RemoteMethodSchema.initFromMethod): same
	* foolscap/pb.py (Listener.addTub): same
	* foolscap/debug.py (TokenBanana.reportReceiveError): same
	* foolscap/copyable.py: same
	* foolscap/test/common.py: same
	* foolscap/test/test_pb.py (TestReferenceable.NOTtestRemoteRef1):
	same

	* foolscap/eventual.py: move eventual-send handling out to a
	separate file. This module now provides eventually(cb),
	d=fireEventually(), and d=flushEventualQueue() (for use by
	unit tests, not user code).
	* foolscap/negotiate.py: update to match
	* foolscap/test/common.py: same
	* foolscap/test/test_pb.py: same
	* foolscap/test/test_eventual.py: new tests for eventually()
	* foolscap/promise.py: rework Promise handling, now it behaves
	like I want it to (although chained Promises aren't working yet)
	* foolscap/test/test_promise.py: rework tests

2006-09-16  Brian Warner  <warner@lothar.com>

	* foolscap/crypto.py: fall back to using our own sslverify.py if
	Twisted doesn't provide one (i.e. Twisted-2.4.x).
	* foolscap/sslverify.py: copy from the Divmod tree

2006-09-14  Brian Warner  <warner@lothar.com>

	* foolscap/banana.py: remove #! line from non-script
	* foolscap/remoteinterface.py: same
	* foolscap/tokens.py: same
	* foolscap/test/test_schema.py: same

	* foolscap/__init__.py: bump to 0.0.2+ while between releases

2006-09-14  Brian Warner  <warner@lothar.com>

	* foolscap/__init__.py: release Foolscap-0.0.2

2006-09-14  Brian Warner  <warner@lothar.com>

	* doc/using-pb.xhtml: update pb3 example to match current usage, show
	an example of using encrypted Tubs
	* doc/listings/pb3calculator.py: same
	* doc/listings/pb3user.py: same

	* foolscap/__init__.py: rearrange the API: now 'import foolscap'
	is the preferred entry point, rather than 'from foolscap import pb'.
	* foolscap/pb.py: stop importing things just to make them available
	to people who import foolscap.pb
	* all: same, update docs, examples, tests

	* all: rename newpb to 'Foolscap'
	* setup.py: fix packages= to get tests too


2006-05-15  Brian Warner  <warner@lothar.com>

	* test_zz_resolve.py: rename test file, I'd like to sit at the end
	of the tests rather than at the beginning. This is to investigate
	ticket #1390.

	* test_negotiate.py (Crossfire): oops, a cut-and-paste error
	resulted in two CrossfireReverse tests and zero Crossfire tests.
	Fixed this to enable the possibly-never-run real CrossfireReverse
	test case.
	(top): disable all negotiation tests unless NEWPB_TEST_NEGOTIATION
	is set in the environment, since they are sensitive to system load
	and the intermittent buildbot failures are annoying.

2006-05-05  Brian Warner  <warner@lothar.com>

	* release-twisted: add 'pb' subproject
	* twisted/python/dist.py: same
	* twisted/pb/__init__.py: set version to 0.0.1
	* twisted/pb/topfiles/setup.py: fix subproject name, set version 0.0.1

2006-04-29  Brian Warner  <warner@lothar.com>

	* topfiles/README, topfiles/NEWS: prepare for 0.0.1 release
	* setup.py: fix up description, project name
	* test_ZZresolve.py: add some instrumentation to try and debug the
	occasional all-connection-related-tests-fail problem, which I
	suspect involves the threadpool being broken.

2006-02-28  Brian Warner  <warner@lothar.com>

	* sslverify.py: update to latest version (r5075) from Vertex SVN,
	to fix a problem reported on OS-X with python2.4 . Removed the
	test-case-name tag to prevent troubles with buildbot on systems
	that don't also have vertex installed. I need to find a better
	solution for this in the long run: I don't want newpb to depend
	upon Vertex, but I also don't want to duplicate code.

2006-02-27  Brian Warner  <warner@lothar.com>

	* debug.py (encodeTokens): return a Deferred rather than use
	deferredResult

2006-02-02  Brian Warner  <warner@lothar.com>

	* test_negotiate.py: skip pb-vs-web tests when we don't have
	twisted.web, thanks to <marienz> for the patch.

2006-01-26  Brian Warner  <warner@lothar.com>

	* test/test_banana.py (ErrorfulSlicer.next): don't use callLater()
	with non-zero timeout
	* test/test_promise.py (TestPromise.test2): same
	* test/common.py (HelperTarget.remote_defer): same

2006-01-25  Brian Warner  <warner@lothar.com>

	* copyable.py: refactor ICopyable and IRemoteCopy to make it
	possible to register adapters for third-party classes.
	(RemoteCopy): allow RemoteCopy to auto-register with the
	fully-qualified classname. This is only useful if you inherit from
	both pb.Copyable and pb.RemoteCopy at the same time, otherwise the
	sender and receiver will be using different names so they won't
	match up.

	* broker.py (PBRootUnslicer.open): now that registerRemoteCopy is
	done purely in terms of Unslicers, remove all the special-case code
	that handled IRemoteCopy
	(PBRootSlicer.slicerForObject): since zope.interface won't do
	transitive adaptation, manually handle the
	ThirdPartyClass -> ICopyable -> ISlicer case

	* test/test_copyable.py: clean up, improve comments
	(MyRemoteCopy3Unslicer): update to match new RemoteCopyUnslicer
	behavior. This needs to be documented and made easier. Also switch
	from pb.registerRemoteCopy to registerRemoteCopyUnslicerFactory,
	which is a mouthful.
	(Registration): split this out, update to match new debug tables
	in copyable.py
	(Adaptation): test ICopyable adapters

2006-01-23  Brian Warner  <warner@lothar.com>

	* common.py: remove missing test_gift from the test-case-name tag,
	not sure how that got in there

	* test/test_copyable.py: split Copyable tests out of test_pb.py
	* test/common.py: factor out some more common test utility pieces
	* copyable.py: add suitable test-case-name tag

	* base32.py: rename Base32.py to base32.py, to match Twisted
	naming conventions
	* crypto.py: same
	* pb.py: same

2006-01-02  Brian Warner  <warner@lothar.com>

	* negotiate.py (eventually): add glyph's eventual-send operator,
	based upon a queue cranked by callLater(0).
	(flushEventualQueue): provide a way to flush that queue, so tests
	know when to finish.
	* test/test_pb.py: switch to negotiate.eventually
	* test/__init__.py: add test-case-name tag

2005-12-31  Brian Warner  <warner@lothar.com>

	* test_gift.py (TestOrderedGifts.testGift): verify that the
	presence of a gift (a third-party reference) in the arguments of a
	method does not cause that method to be run out-of-order. Marked
	TODO because at the moment they *are* run out-of-order.
	* common.py (RIHelper.append): new method

	* referenceable.py (TheirReferenceUnslicer.ackGift): ignore errors
	that involve losing the connection, since if these happen, the
	giver will decref the gift reference anyway. This removes some
	spurious log.errs and makes the unit tests happier.

2005-12-30  Brian Warner  <warner@lothar.com>

	* test_negotiate.py (Versus.testVersusHTTPServerEncrypted): stall
	for a second after the test completes, to give the HTTP server a
	moment to tear down its socket. Otherwise trial flunks the test
	because of the lingering socket. I don't care for the arbitrary
	1.0-second delay, but twisted.web doesn't give me any convenient
	way to wait for it to shut down. (this test was only failing under
	the gtk2 reactor, but I think this was an unlucky timing thing).
	(Versus.testVersusHTTPServerUnencrypted): same

	* negotiate.py (eventually): add an eventual-send operator
	(Negotiation.negotiationFailed): fire connector.negotiationFailed
	through eventually(), to give us a chance to loseConnection
	beforehand. This helps the unit tests clean up better.

	* negotiation.py (eventually): change the eventual-send operator
	to (ab)use reactor.callFromThread instead of callLater(0). exarkun
	warned me, but I didn't listen: callLater(0) does not guarantee
	relative ordering of sequentially-scheduled calls, and the windows
	reactors in fact execute them in random order. Obviously I'd like
	the reactor to provide a clearly-defined method for this purpose.
	* test_pb.py (eventually): same
	(Loopback.write): same. It was the reordering of these _write
	calls that was breaking the unit tests on windows so badly.
	(Loopback.loseConnection): same


2005-12-29  Brian Warner  <warner@lothar.com>

	* test_pb.py (Loopback): fix plan-coordination bug by deferring
	all write() and loseConnection() calls until the next reactor
	turn, using reactor.callLater(0) as an 'eventual send' operator.
	This avoids an infinite-mutual-recursion hang that confuses
	certain test failures. Tests which use this Loopback must call
	flush() and wait on the returned Deferred before finishing.
	(TargetMixin): do proper setup/teardown of Loopback
	(TestCall.testDisconnect2): use proper CONNECTION_LOST exception
	(TestCall.testDisconnect3): same
	(TestReferenceable.testArgs1): rename some tests
	(TestReferenceable.testArgs2): test sending shared objects in
	multiple arguments of a single method call
	(TestReferenceable.testAnswer1): test shared objects in the return
	value of a method call
	(TestReferenceable.testAnswer2): another test for return values

	* call.py (CallUnslicer): inherit from ScopedUnslicer, so
	arguments that reference shared objects will accurately reproduce
	the object graph
	(AnswerUnslicer): same, for answers that have shared objects
	(ErrorUnslicer): same, just in case serialized Failures do too
	* slicer.py (ImmutableSetSlicer): set trackReferences=False, since
	immutable objects are never shared, so don't require reference
	tracking

	* banana.py (Banana.sendError): do loseConnection() in sendError
	rather than inside dataReceived.

2005-12-26  Brian Warner  <warner@lothar.com>

	* slicer.py (ScopedSlicer.registerReference): track references
	with a (obj,refid) pair instead of just refid. This insures that
	the object being tracked stays alive until the scope is retired,
	preventing some ugly bugs that result from dead object id() values
	being reused. These bugs would only happen if the object graph
	changes during serialization (which you aren't supposed to do),
	but this is a cheap fix that limits the damage that could happen.
	In particular, it should fix a test failure on the OS-X buildslave
	that results from a unit test that is violating this object-graph
	-shouldn't-change prohibition.

	* banana.py (StorageBanana): refactor storage-related things,
	moving them from banana.py and slicer.py into the new storage.py .
	This includes UnsafeRootSlicer, StorageRootSlicer,
	UnsafeRootUnslicer, and StorageRootUnslicer. Also provide a simple
	serialize()/unserialize() pair in twisted.pb.storage, which will
	be the primary interface for simple pickle.dumps()-like
	serialization.

2005-12-24  Brian Warner  <warner@lothar.com>

	* slicer.py: remove #!, add test-case-name
	(SetSlicer): define this unconditionally, now that python2.2 is no
	longer supported.
	(BuiltinSetSlicer): just like SetSlicer, used when there is a builtin
	'set' type (python2.4 and higher)
	(ImmutableSetSlicer): define this unconditionally
	(SetUnslicer): same
	(ImmutableSetUnslicer): same

	* test_banana.py (TestBananaMixin.looptest): make it easier to
	test roundtrip encode/decode pairs that don't *quite* re-create
	the original object
	(TestBananaMixin.loop): clear the token stream for each test
	(ThereAndBackAgain.test_set): verify that python2.4's builtin
	'set' type is serialized as a sets.Set

	* all: drop python2.2 compatibility, now that Twisted no longer
	supports it

2005-12-22  Brian Warner  <warner@lothar.com>

	* pb.py (Listener.getPortnum): more python2.2 fixes, str in str
	(PBService.__init__): same, bool issues
	* test/test_banana.py: same, use failUnlessSubstring
	* test/test_negotiate.py: same
	* test/test_pb.py: same
	* negotiate.py: same, str in str stuff

	* broker.py: don't import itertools, for python2.2 compatibility
	* sslverify.py: same

2005-12-20  Brian Warner  <warner@lothar.com>

	* test/test_banana.py: remove all remaining uses of
	deferredResult/deferredError
	* test/test_pb.py: same

2005-12-09  Brian Warner  <warner@lothar.com>

	* pb.py (PBService.__init__): switch to SHA-1 for TubID digests
	* negotiate.py (Negotiation.evaluateHello): same
	* crypto.py (digest32): same

2005-12-08  Brian Warner  <warner@lothar.com>

	* pb.py (PBService): allow all Tubs to share the same RandomPool

2005-10-10  Brian Warner  <warner@lothar.com>

	* lots: overhaul negotiation, add lots of new tests. Implement
	shared Listeners, correct handling of both encrypted and
	non-encrypted Tubs, follow multiple locationHints correctly. More
	docs, update encrypted-tub examples to match new usage.

2005-09-15  Brian Warner  <warner@lothar.com>

	* test_pb.py: remove some uses of deferredResult/deferredError

2005-09-14  Brian Warner  <warner@lothar.com>

	* pb.py (PBService.generateSwissnumber): use PyCrypto RNG if
	available, otherwise use the stdlib 'random' module. Create a
	160-bit swissnumber by default, this can be changed by the
	NAMEBITS class attribute.
	(PBService.__init__): use a random 32-bit number as a TubID when
	we aren't using crypto and an SSL certificate
	* Base32.py: copy module from the waterken.org Web-Calculus
	python implementation
	* test/test_crypto.py (TestService.getRef): let it register a
	random swissnumber instead of a well-known name


	* crypto.py: Implement encrypted PB connections, so PB-URLs are
	closer to being secure capabilities. This file contains utility
	functions.
	* sslverify.py: some pyOpenSSL wrappers, copied from Divmod's
	Vertex/vertex/sslverify.py

	* test/test_crypto.py: test case for encrypted connections

	* pb.py (PBServerFactory.buildProtocol): accomodate missing tubID,
	this needs to be re-thought when I do the "what if we aren't using
	crypto" pass.
	(PBServerFactory.clientConnectionMade): get the remote_tubid from
	a .theirTubID attribute, not the negotiated connection parameters,
	which won't include tub IDs anyway)
	(PBClientFactory.buildProtocol): if we're using crypto, tell the
	other side we want an encrypted connection
	(PBService.__init__): add useCrypto= parameter, currently defaults
	to False. This should switch to =True soon.
	(PBService.createCertificate): if useCrypto=True, create an SSL
	certificate for the Tub.

	* ipb.py (DeadReferenceError): actually define it somewhere

	* broker.py (Broker.handleNegotiation_v1): cleanup, make the
	different negotiation-parameter dictionaries distinct, track the
	['my-tub-id'] field of each end more carefully. Start a TLS
	session when both ends want it.
	(Broker.startTLS): method to actually start the TLS session. This
	is called on both sides (client and server), the t.i.ssl
	subclasses figure out which is which and inform SSL appropriately.
	(Broker.acceptNegotiation): Make a PB-specific form. Start TLS if
	the server tells us to. When the second (encrypted) negotiation
	block arrives, verify that the TubID we're looking for matches
	both what they claim and what their SSL certificate contains.
	(Broker.freeYourReference): ignore DeadReferenceErrors too

	* banana.py (Banana.__init__): each instance must have its own
	copy of self.negotiationOffer, rather than setting it at the class
	level
	(Banana.negotiationDataReceived): let both handleNegotiation() and
	acceptNegotiation() return a 'done' flag, if False then the
	negotiation is re-started
	(Banana.handleNegotiation): make handleNegotiation_v1 responsible
	for setting self.negotiationResults
	(Banana.handleNegotiation_v1): same
	(Banana.acceptNegotiation): same

2005-09-09  Brian Warner  <warner@lothar.com>

	* broker.py: big sanity-cleanup of RemoteInterface usage. Only
	allow a single RemoteInterface on any given pb.Referenceable.
	Tub.getReference() now only takes a string-form method name, so
	the rr.callRemote(RIFoo['bar'], *args) form is gone, and the one
	RemoteInterface associated with the RemoteReference (is available)
	will be checked. Tub.getReference() no longer takes an interface
	name: you request an object, and then later find out what it
	implements (rather than specifying your expectations ahead of
	time). Gifts (i.e. 'their-reference' sequences) no longer have an
	interfacename.. that is left up to the actual owner of the
	reference, who will provide it in the 'my-reference' sequence.
	* call.py, pb.py, referenceable.py, remoteinterface.py: same
	* test/test_pb.py: update to match, still needs some cleanup

2005-09-08  Brian Warner  <warner@lothar.com>

	* setup.py, twisted/pb/topfiles: add "PB" sub-project

	* banana.py (Banana.sendFailed): oops, loseConnection() doesn't
	take an argument

	* copyable.py (RemoteCopyClass): make it possible to disable
	auto-registration of RemoteCopy classes
	* test/test_pb.py (TestCopyable.testRegistration): test it

	* referenceable.py (CallableSlicer): make it possible to publish
	callables (bound methods in particular) as secure capabilities.
	They are handled very much like pb.Referenceable, but with a
	negative CLID number and a slightly different callRemote()
	codepath.
	* broker.py (Broker.getTrackerForMyCall): same
	(Broker.getTrackerForYourReference): same, use a
	RemoteMethodReferenceTracker for negative CLID values
	(Broker.doCall): callables are distinguished by having a
	methodname of 'None', and are dispatched differently
	* call.py (CallUnslicer.checkToken): accept INT/NEG for the object
	ID (the CLID), but not string (leftover from old scheme)
	(CallUnslicer.receiveChild): handle negative CLIDs specially
	* test/test_pb.py (TestCallable): tests for it all
	(TestService.getRef): refactor
	(TestService.testStatic): verify that we can register static data
	too, at least stuff that can be hashed. We need to decide whether
	it would be useful to publish non-hashable static data too.

2005-09-05  Brian Warner  <warner@lothar.com>

	* pb.py (PBService): move to using tubIDs as the primary identity
	key for a Tub, replacing the baseURL with a .location attribute.
	Look up references by name instead of by URL, and start using
	SturdyRefs locally instead of URLs whenever possible.
	(PBService.getReference): accept either a SturdyRef or a URL
	(RemoteTub.__init__): take a list of locationHints instead of a
	single location. The try-all-of-them code is not yet written, nor
	is the optional redirect-following.
	(RemoteTub.getReference): change the inter-Tub protocol to pass a
	name over the wire instead of a full URL. The Broker is already
	connected to a specific Tub (multiple Tubs sharing the same port
	will require separate Brokers), and by this point the location
	hints have already served their purpose, so the name is the only
	appropriate thing left to send.

	* broker.py (RIBroker.getReferenceByName): match that change to
	the inter-Tub protocol: pass name over the wire, not URL
	(Broker.getYourReferenceByName): same
	(Broker.remote_getReferenceByName): same

	* referenceable.py (RemoteReferenceOnly): replace getURL with
	getSturdyRef, since the SturdyRef can be stringified into a URL if
	necessary
	(SturdyRef): new class. When these are sent over the wire, they
	appear at the far end as an identical SturdyRef; if you want them
	to appear as a live reference, send sr.asLiveRef() instead.

	* test/test_pb.py (TestService.testRegister): match changes
	(Test3Way.setUp): same
	(HelperTarget.__init__): add some debugging annotations
	* test/test_sturdyref.py: new test

	* doc/pb/using-pb.xhtml: update to match new usage, explain PB
	URLs and secure identifiers
	* doc/pb/listings/pb1server.py: same
	* doc/pb/listings/pb1client.py: same
	* doc/pb/listings/pb2calculator.py: same
	* doc/pb/listings/pb2user.py: same

2005-05-12  Brian Warner  <warner@lothar.com>

	* doc/pb/using-pb.xhtml: document RemoteInterface, Constraints,
	most of Copyable (still need examples), Introductions (third-party
	references).
	* doc/pb/listings/pb2calculator.py, pb2user.py: demostrate
	bidirectional references, using service.Application

2005-05-10  Brian Warner  <warner@lothar.com>

	* broker.py (Broker.freeYourReference): also ignore ConnectionLost
	errors
	* doc/pb/listings/pb1client.py, pb1server.py: use reactor.run()
	* doc/pb/using-pb.xhtml: add shell output for examples

	* doc/pb/using-pb.xhtml: started writing usage docs

	* banana.py (Banana.dataReceived): add .connectionAbandoned, don't
	accept inbound data if it has been set. I don't trust
	.loseConnection to work right away, and sending multiple
	negotiation error messages is bad.
	(Banana.negotiationDataReceived): split out negotiation stuff to a
	separate method. Improve failure-reporting code to make sure we
	either report a problem with a negotation block, or with an ERROR
	token, not both, and not with multiple ERROR tokens. Catch errors
	in the upper-level bananaVersionNegotiated() call. Make sure we
	only send a response if we're the server. Report negotiation errors
	with NegotiationError, not BananaError.
	(Banana.reportReceiveError): rearrange a bit, accept a Failure
	object. Don't do transport.loseConnection here, do it in whatever
	calls reportReceiveError
	* debug.py (TokenBanana.reportReceiveError): match signature change
	(TokenStorageBanana.reportReceiveError): same
	* test/test_banana.py: match changes
	* tokens.py (NegotiationError): new exception

	* broker.py (Broker.handleNegotiation_v1): use the negotiation
	block to exchange TubIDs.
	(Broker.connectionFailed): tell the factory if negotiation failed
	(Broker.freeYourReference): ignore lost-connection errors, call
	freeYourReferenceTracker even if the connection was lost, since
	in that case the reference has gone away anyway.
	(Broker.freeYourReferenceTracker): don't explode if the keys were
	already deleted, since .connectionLost will clear everything
	before the decref-ack mechanism gets a chance to delete them.
	* referenceable.py (RemoteReferenceTracker.__repr__): stringify
	these with more useful information.
	* pb.py (PBServerFactory.buildProtocol): copy .debugBanana flag
	into the new Broker (both .debugSend and .debugReceive)
	(PBServerFactory.clientConnectionMade): survive a missing TubID
	(PBClientFactory.negotiationFailed): notify all onConnect watchers

2005-05-08  Brian Warner  <warner@lothar.com>

	* test_pb.py (TestService): test the use of PBService without
	RemoteInterfaces too

2005-05-04  Brian Warner  <warner@lothar.com>

	* broker.py (Broker): add tables to track gifts (third-party
	references)
	(PBOpenRegistry): add their-reference entry
	(RIBroker.decgift): new method to release pending gifts
	* call.py (PendingRequest): add some debugging hints
	(CallUnslicer): accept deferred arguments, don't invoke the method
	until all arguments are available
	* pb.py (PBService.listenOn): return the Service, for testing
	(PBService.generateUnguessableName): at least make them unique,
	if not actually unguessable
	(top): remove old URL code, all is now PBService
	* referenceable.py (RemoteReferenceOnly.__repr__): include the
	URL, if available
	(RemoteReference.callRemote): set .methodName on the
	PendingRequest, to make debugging easier
	(YourReferenceSlicer.slice): handle third-party references
	(TheirReferenceUnslicer): accept third-party references
	* schema.py (Nothing): a constraint which only accepts None
	* test/test_pb.py (Test3Way): validate third-party reference gifts

2005-04-28  Brian Warner  <warner@lothar.com>

	* tokens.py (IReferenceable): move to flavors.py
	* flavors.py (IReferenceable): add it, mark Referenceable as
	implementing it.
	* pb.py (PBServerFactory): make root= optional
	(PBService): new class. In the future, all PB uses will go through
	this service, rather than using factories and connectTCPs directly.
	The service uses urlparse to map PB URLs to target hosts.
	* test_pb.py (TestService): start adding tests for PBService

2005-04-26  Brian Warner  <warner@lothar.com>

	* banana.py: add preliminary newpb connection negotiation
	* test_banana.py: start on tests for negotiation, at least verify
	that newpb-newpb works, and that newpb-http and http-newpb fail.

2005-04-16  Brian Warner  <warner@lothar.com>

	* banana.py (Banana.handleData): handle -2**31 properly
	* test_banana.py (ThereAndBackAgain.test_bigint): test it properly

	* flavors.py: python2.2 compatibility: __future__.generators
	* pb.py: same
	* schema.py (TupleConstraint.maxSize): don't use sum()
	(AttributeDictConstraint.maxSize): same
	(makeConstraint): in 2.2, 'bool' is a function, not a type, and
	there is no types.BooleanType
	* slicer.py: __future__.generators, and the 'sets' module might not
	be available
	(SetSlicer): only define it if 'sets' is available
	(SetUnslicer): same
	* test_banana.py: __future__.generators, 'sets' might not exist,
	(EncodeFailureTest.failUnlessIn): 2.2 can't do 'str in str', only
	'char in str', so use str.find() instead
	(InboundByteStream2.testConstrainedBool): skip bool constraints
	unless we have a real BooleanType
	(ThereAndBackAgain.test_set): skip sets unless they're supported
	* test_schema.py (ConformTest.testBool): skip on 2.2
	(CreateTest.testMakeConstraint): same
	* test_pb.py: __future__.generators, use str.find()

	* test_banana.py (DecodeTest.test_ref2): accomodate python2.4,
	which doesn't try to be quite as clever as python2.3 when
	comparing complex object graphs with ==
	(DecodeTest.test_ref5): same. Do the comparison by hand.
	(DecodeTest.test_ref6): same, big gnarly validation phase

	* test_pb.py (TestReferenceUnslicer.testNoInterfaces): update to
	new signature for receiveClose()
	(TestReferenceUnslicer.testInterfaces): same
	(TestCall.testFail1): deferredError doesn't seem to like
	CopiedFailure all that much. Use retrial's return-a-deferred
	support instead.
	(MyRemoteCopy3Unslicer.receiveClose): same
	(TestCall.testFail2): same
	(TestCall.testFail3): same
	(TestFactory): clean up both server and client sockets, to avoid
	the "unclean reactor" warning from trial
	(Test3Way.tearDown): clean up client sockets

	* tokens.py (receiveClose): fix documentation

	* pb.py (CopiedFailure): make CopiedFailure old-style, since you
	can't raise new-style instances as exceptions, and CopiedFailure
	may have its .trap() method invoked, which does 'raise self'.
	(CopiedFailure.__str__): make it clear that this is a
	CopiedFailure, not a normal Failure.
	(callRemoteURL_TCP): Add a _gotReferenceCallback argument, to
	allow test cases to clean up their client connections.

	* flavors.py (RemoteCopyOldStyle): add an old-style base class, so
	CopiedFailure can be old-style. Make RemoteCopy a new-style
	derivative.

	* test_banana.py (DecodeTest.test_instance): fix the
	manually-constructed class names to reflect their new location in
	the tree (test_banana to twisted.pb.test.test_banana)
	(EncodeFailureTest.test_instance_unsafe): same

	* twisted/pb/*: move newpb from Sandbox/warner into the 'newpb'
	branch, distributed out in twisted/pb/ and doc/pb/
	* twisted/pb: add __init__.py files to make it a real module
	* twisted/pb/test/test_*.py: fix up import statements

2005-03-22  Brian Warner  <warner@twistedmatrix.com>

	* flavors.py: implement new signature
	* pb.py: same
	* test_pb.py: same

	* test_banana.py (BrokenDictUnslicer.receiveClose): new signature
	(ErrorfulUnslicer.receiveChild): same
	(ErrorfulUnslicer.receiveClose): same
	(FailingUnslicer.receiveChild): same

	* slicer.py: implement new receiveChild/receiveClose signature.
	Require that ready_deferred == None for now.
	(ListUnslicer.receiveChild): put "placeholder" in the list instead
	of the Deferred
	(TupleUnslicer.start): change the way we keep track of
	not-yet-constructable tuples, using a counter of unreferenceable
	children instead of counting the Deferred placeholders in the list
	(TupleUnslicer.receiveChild): put "placeholder" in the list
	instead of the Deferred

	* banana.py (Banana.reportReceiveError): when debugging, log the
	exception in a way that doesn't cause trial to think the test
	failed.
	(Banana.handleToken): implement new receiveChild signature
	(Banana.handleClose): same
	* debug.py (LoggingBananaMixin.handleToken): same

	* tokens.py (IUnslicer.receiveChild): new signature for
	receiveClose and receiveChild, they now pass a pair of (obj,
	ready_deferred), where obj is still object-or-deferred, but
	ready_deferred is non-None when the object will not be ready to
	use until some other event takes place (like a "slow" global
	reference is established).

# Local Variables:
# add-log-time-format: add-log-iso8601-time-string
# End:
